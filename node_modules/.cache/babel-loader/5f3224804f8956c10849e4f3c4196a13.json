{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generate = exports.compile = void 0;\n\nvar boolbase_1 = __importDefault(require(\"boolbase\"));\n/**\n * Returns a function that checks if an elements index matches the given rule\n * highly optimized to return the fastest solution.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A highly optimized function that returns whether an index matches the nth-check.\n * @example\n *\n * ```js\n * const check = nthCheck.compile([2, 3]);\n *\n * check(0); // `false`\n * check(1); // `false`\n * check(2); // `true`\n * check(3); // `false`\n * check(4); // `true`\n * check(5); // `false`\n * check(6); // `true`\n * ```\n */\n\n\nfunction compile(parsed) {\n  var a = parsed[0]; // Subtract 1 from `b`, to convert from one- to zero-indexed.\n\n  var b = parsed[1] - 1;\n  /*\n   * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.\n   * Besides, the specification states that no elements are\n   * matched when `a` and `b` are 0.\n   *\n   * `b < 0` here as we subtracted 1 from `b` above.\n   */\n\n  if (b < 0 && a <= 0) return boolbase_1.default.falseFunc; // When `a` is in the range -1..1, it matches any element (so only `b` is checked).\n\n  if (a === -1) return function (index) {\n    return index <= b;\n  };\n  if (a === 0) return function (index) {\n    return index === b;\n  }; // When `b <= 0` and `a === 1`, they match any element.\n\n  if (a === 1) return b < 0 ? boolbase_1.default.trueFunc : function (index) {\n    return index >= b;\n  };\n  /*\n   * Otherwise, modulo can be used to check if there is a match.\n   *\n   * Modulo doesn't care about the sign, so let's use `a`s absolute value.\n   */\n\n  var absA = Math.abs(a); // Get `b mod a`, + a if this is negative.\n\n  var bMod = (b % absA + absA) % absA;\n  return a > 1 ? function (index) {\n    return index >= b && index % absA === bMod;\n  } : function (index) {\n    return index <= b && index % absA === bMod;\n  };\n}\n\nexports.compile = compile;\n/**\n * Returns a function that produces a monotonously increasing sequence of indices.\n *\n * If the sequence has an end, the returned function will return `null` after\n * the last index in the sequence.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A function that produces a sequence of indices.\n * @example <caption>Always increasing (2n+3)</caption>\n *\n * ```js\n * const gen = nthCheck.generate([2, 3])\n *\n * gen() // `1`\n * gen() // `3`\n * gen() // `5`\n * gen() // `8`\n * gen() // `11`\n * ```\n *\n * @example <caption>With end value (-2n+10)</caption>\n *\n * ```js\n *\n * const gen = nthCheck.generate([-2, 5]);\n *\n * gen() // 0\n * gen() // 2\n * gen() // 4\n * gen() // null\n * ```\n */\n\nfunction generate(parsed) {\n  var a = parsed[0]; // Subtract 1 from `b`, to convert from one- to zero-indexed.\n\n  var b = parsed[1] - 1;\n  var n = 0; // Make sure to always return an increasing sequence\n\n  if (a < 0) {\n    var aPos_1 = -a; // Get `b mod a`\n\n    var minValue_1 = (b % aPos_1 + aPos_1) % aPos_1;\n    return function () {\n      var val = minValue_1 + aPos_1 * n++;\n      return val > b ? null : val;\n    };\n  }\n\n  if (a === 0) return b < 0 ? // There are no result â€” always return `null`\n  function () {\n    return null;\n  } : // Return `b` exactly once\n  function () {\n    return n++ === 0 ? b : null;\n  };\n\n  if (b < 0) {\n    b += a * Math.ceil(-b / a);\n  }\n\n  return function () {\n    return a * n++ + b;\n  };\n}\n\nexports.generate = generate;","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;AAoBA,SAAgBA,OAAhB,CACIC,MADJ,EACkC;EAE9B,IAAMC,CAAC,GAAGD,MAAM,CAAC,CAAD,CAAhB,CAF8B,CAG9B;;EACA,IAAME,CAAC,GAAGF,MAAM,CAAC,CAAD,CAAN,GAAY,CAAtB;EAEA;;;;;;;;EAOA,IAAIE,CAAC,GAAG,CAAJ,IAASD,CAAC,IAAI,CAAlB,EAAqB,OAAOE,mBAASC,SAAhB,CAbS,CAe9B;;EACA,IAAIH,CAAC,KAAK,CAAC,CAAX,EAAc,OAAO,UAACI,KAAD,EAAM;IAAK,YAAK,IAAIH,CAAT;EAAU,CAA5B;EACd,IAAID,CAAC,KAAK,CAAV,EAAa,OAAO,UAACI,KAAD,EAAM;IAAK,YAAK,KAAKH,CAAV;EAAW,CAA7B,CAjBiB,CAkB9B;;EACA,IAAID,CAAC,KAAK,CAAV,EAAa,OAAOC,CAAC,GAAG,CAAJ,GAAQC,mBAASG,QAAjB,GAA4B,UAACD,KAAD,EAAM;IAAK,YAAK,IAAIH,CAAT;EAAU,CAAxD;EAEb;;;;;;EAKA,IAAMK,IAAI,GAAGC,IAAI,CAACC,GAAL,CAASR,CAAT,CAAb,CA1B8B,CA2B9B;;EACA,IAAMS,IAAI,GAAG,CAAER,CAAC,GAAGK,IAAL,GAAaA,IAAd,IAAsBA,IAAnC;EAEA,OAAON,CAAC,GAAG,CAAJ,GACD,UAACI,KAAD,EAAM;IAAK,YAAK,IAAIH,CAAT,IAAcG,KAAK,GAAGE,IAAR,KAAiBG,IAA/B;EAAmC,CAD7C,GAED,UAACL,KAAD,EAAM;IAAK,YAAK,IAAIH,CAAT,IAAcG,KAAK,GAAGE,IAAR,KAAiBG,IAA/B;EAAmC,CAFpD;AAGH;;AAlCDC;AAoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA,SAAgBC,QAAhB,CAAyBZ,MAAzB,EAAuD;EACnD,IAAMC,CAAC,GAAGD,MAAM,CAAC,CAAD,CAAhB,CADmD,CAEnD;;EACA,IAAIE,CAAC,GAAGF,MAAM,CAAC,CAAD,CAAN,GAAY,CAApB;EAEA,IAAIa,CAAC,GAAG,CAAR,CALmD,CAOnD;;EACA,IAAIZ,CAAC,GAAG,CAAR,EAAW;IACP,IAAMa,MAAI,GAAG,CAACb,CAAd,CADO,CAEP;;IACA,IAAMc,UAAQ,GAAG,CAAEb,CAAC,GAAGY,MAAL,GAAaA,MAAd,IAAsBA,MAAvC;IACA,OAAO;MACH,IAAME,GAAG,GAAGD,UAAQ,GAAGD,MAAI,GAAGD,CAAC,EAA/B;MAEA,OAAOG,GAAG,GAAGd,CAAN,GAAU,IAAV,GAAiBc,GAAxB;IACH,CAJD;EAKH;;EAED,IAAIf,CAAC,KAAK,CAAV,EACI,OAAOC,CAAC,GAAG,CAAJ,GACD;EACA;IAAM;EAAI,CAFT,GAGD;EACA;IAAM,OAACW,CAAC,OAAO,CAAR,GAAYX,CAAZ,GAAgB,IAAjB;EAAsB,CAJlC;;EAMJ,IAAIA,CAAC,GAAG,CAAR,EAAW;IACPA,CAAC,IAAID,CAAC,GAAGO,IAAI,CAACS,IAAL,CAAU,CAACf,CAAD,GAAKD,CAAf,CAAT;EACH;;EAED,OAAO;IAAM,QAAC,GAAGY,CAAC,EAAL,GAAUX,CAAV;EAAW,CAAxB;AACH;;AA/BDS","names":["compile","parsed","a","b","boolbase_1","falseFunc","index","trueFunc","absA","Math","abs","bMod","exports","generate","n","aPos_1","minValue_1","val","ceil"],"sources":["compile.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uniqueSort = exports.compareDocumentPosition = exports.DocumentPosition = exports.removeSubsets = void 0;\n\nvar domhandler_1 = require(\"domhandler\");\n/**\n * Given an array of nodes, remove any member that is contained by another.\n *\n * @category Helpers\n * @param nodes Nodes to filter.\n * @returns Remaining nodes that aren't subtrees of each other.\n */\n\n\nfunction removeSubsets(nodes) {\n  var idx = nodes.length;\n  /*\n   * Check if each node (or one of its ancestors) is already contained in the\n   * array.\n   */\n\n  while (--idx >= 0) {\n    var node = nodes[idx];\n    /*\n     * Remove the node if it is not unique.\n     * We are going through the array from the end, so we only\n     * have to check nodes that preceed the node under consideration in the array.\n     */\n\n    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {\n      nodes.splice(idx, 1);\n      continue;\n    }\n\n    for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n      if (nodes.includes(ancestor)) {\n        nodes.splice(idx, 1);\n        break;\n      }\n    }\n  }\n\n  return nodes;\n}\n\nexports.removeSubsets = removeSubsets;\n/**\n * @category Helpers\n * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}\n */\n\nvar DocumentPosition;\n\n(function (DocumentPosition) {\n  DocumentPosition[DocumentPosition[\"DISCONNECTED\"] = 1] = \"DISCONNECTED\";\n  DocumentPosition[DocumentPosition[\"PRECEDING\"] = 2] = \"PRECEDING\";\n  DocumentPosition[DocumentPosition[\"FOLLOWING\"] = 4] = \"FOLLOWING\";\n  DocumentPosition[DocumentPosition[\"CONTAINS\"] = 8] = \"CONTAINS\";\n  DocumentPosition[DocumentPosition[\"CONTAINED_BY\"] = 16] = \"CONTAINED_BY\";\n})(DocumentPosition = exports.DocumentPosition || (exports.DocumentPosition = {}));\n/**\n * Compare the position of one node against another node in any other document.\n * The return value is a bitmask with the values from {@link DocumentPosition}.\n *\n * Document order:\n * > There is an ordering, document order, defined on all the nodes in the\n * > document corresponding to the order in which the first character of the\n * > XML representation of each node occurs in the XML representation of the\n * > document after expansion of general entities. Thus, the document element\n * > node will be the first node. Element nodes occur before their children.\n * > Thus, document order orders element nodes in order of the occurrence of\n * > their start-tag in the XML (after expansion of entities). The attribute\n * > nodes of an element occur after the element and before its children. The\n * > relative order of attribute nodes is implementation-dependent.\n *\n * Source:\n * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n *\n * @category Helpers\n * @param nodeA The first node to use in the comparison\n * @param nodeB The second node to use in the comparison\n * @returns A bitmask describing the input nodes' relative position.\n *\n * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n * a description of these values.\n */\n\n\nfunction compareDocumentPosition(nodeA, nodeB) {\n  var aParents = [];\n  var bParents = [];\n\n  if (nodeA === nodeB) {\n    return 0;\n  }\n\n  var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;\n\n  while (current) {\n    aParents.unshift(current);\n    current = current.parent;\n  }\n\n  current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;\n\n  while (current) {\n    bParents.unshift(current);\n    current = current.parent;\n  }\n\n  var maxIdx = Math.min(aParents.length, bParents.length);\n  var idx = 0;\n\n  while (idx < maxIdx && aParents[idx] === bParents[idx]) {\n    idx++;\n  }\n\n  if (idx === 0) {\n    return DocumentPosition.DISCONNECTED;\n  }\n\n  var sharedParent = aParents[idx - 1];\n  var siblings = sharedParent.children;\n  var aSibling = aParents[idx];\n  var bSibling = bParents[idx];\n\n  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n    if (sharedParent === nodeB) {\n      return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;\n    }\n\n    return DocumentPosition.FOLLOWING;\n  }\n\n  if (sharedParent === nodeA) {\n    return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;\n  }\n\n  return DocumentPosition.PRECEDING;\n}\n\nexports.compareDocumentPosition = compareDocumentPosition;\n/**\n * Sort an array of nodes based on their relative position in the document and\n * remove any duplicate nodes. If the array contains nodes that do not belong to\n * the same document, sort order is unspecified.\n *\n * @category Helpers\n * @param nodes Array of DOM nodes.\n * @returns Collection of unique nodes, sorted in document order.\n */\n\nfunction uniqueSort(nodes) {\n  nodes = nodes.filter(function (node, i, arr) {\n    return !arr.includes(node, i + 1);\n  });\n  nodes.sort(function (a, b) {\n    var relative = compareDocumentPosition(a, b);\n\n    if (relative & DocumentPosition.PRECEDING) {\n      return -1;\n    } else if (relative & DocumentPosition.FOLLOWING) {\n      return 1;\n    }\n\n    return 0;\n  });\n  return nodes;\n}\n\nexports.uniqueSort = uniqueSort;","map":{"version":3,"mappings":";;;;;;;AAAA;AAEA;;;;;;;;;AAOA,SAAgBA,aAAhB,CAA8BC,KAA9B,EAA8C;EAC1C,IAAIC,GAAG,GAAGD,KAAK,CAACE,MAAhB;EAEA;;;;;EAIA,OAAO,EAAED,GAAF,IAAS,CAAhB,EAAmB;IACf,IAAME,IAAI,GAAGH,KAAK,CAACC,GAAD,CAAlB;IAEA;;;;;;IAKA,IAAIA,GAAG,GAAG,CAAN,IAAWD,KAAK,CAACI,WAAN,CAAkBD,IAAlB,EAAwBF,GAAG,GAAG,CAA9B,KAAoC,CAAnD,EAAsD;MAClDD,KAAK,CAACK,MAAN,CAAaJ,GAAb,EAAkB,CAAlB;MACA;IACH;;IAED,KAAK,IAAIK,QAAQ,GAAGH,IAAI,CAACI,MAAzB,EAAiCD,QAAjC,EAA2CA,QAAQ,GAAGA,QAAQ,CAACC,MAA/D,EAAuE;MACnE,IAAIP,KAAK,CAACQ,QAAN,CAAeF,QAAf,CAAJ,EAA8B;QAC1BN,KAAK,CAACK,MAAN,CAAaJ,GAAb,EAAkB,CAAlB;QACA;MACH;IACJ;EACJ;;EAED,OAAOD,KAAP;AACH;;AA7BDS;AA8BA;;;;;AAIA,IAAkBC,gBAAlB;;AAAA,WAAkBA,gBAAlB,EAAkC;EAC9BA;EACAA;EACAA;EACAA;EACAA;AACH,CAND,EAAkBA,gBAAgB,GAAhBD,wDAAgB,EAAhB,CAAlB;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,SAAgBE,uBAAhB,CACIC,KADJ,EAEIC,KAFJ,EAEkB;EAEd,IAAMC,QAAQ,GAAiB,EAA/B;EACA,IAAMC,QAAQ,GAAiB,EAA/B;;EAEA,IAAIH,KAAK,KAAKC,KAAd,EAAqB;IACjB,OAAO,CAAP;EACH;;EAED,IAAIG,OAAO,GAAG,8BAAYJ,KAAZ,IAAqBA,KAArB,GAA6BA,KAAK,CAACL,MAAjD;;EACA,OAAOS,OAAP,EAAgB;IACZF,QAAQ,CAACG,OAAT,CAAiBD,OAAjB;IACAA,OAAO,GAAGA,OAAO,CAACT,MAAlB;EACH;;EACDS,OAAO,GAAG,8BAAYH,KAAZ,IAAqBA,KAArB,GAA6BA,KAAK,CAACN,MAA7C;;EACA,OAAOS,OAAP,EAAgB;IACZD,QAAQ,CAACE,OAAT,CAAiBD,OAAjB;IACAA,OAAO,GAAGA,OAAO,CAACT,MAAlB;EACH;;EAED,IAAMW,MAAM,GAAGC,IAAI,CAACC,GAAL,CAASN,QAAQ,CAACZ,MAAlB,EAA0Ba,QAAQ,CAACb,MAAnC,CAAf;EACA,IAAID,GAAG,GAAG,CAAV;;EACA,OAAOA,GAAG,GAAGiB,MAAN,IAAgBJ,QAAQ,CAACb,GAAD,CAAR,KAAkBc,QAAQ,CAACd,GAAD,CAAjD,EAAwD;IACpDA,GAAG;EACN;;EAED,IAAIA,GAAG,KAAK,CAAZ,EAAe;IACX,OAAOS,gBAAgB,CAACW,YAAxB;EACH;;EAED,IAAMC,YAAY,GAAGR,QAAQ,CAACb,GAAG,GAAG,CAAP,CAA7B;EACA,IAAMsB,QAAQ,GAAcD,YAAY,CAACE,QAAzC;EACA,IAAMC,QAAQ,GAAGX,QAAQ,CAACb,GAAD,CAAzB;EACA,IAAMyB,QAAQ,GAAGX,QAAQ,CAACd,GAAD,CAAzB;;EAEA,IAAIsB,QAAQ,CAACI,OAAT,CAAiBF,QAAjB,IAA6BF,QAAQ,CAACI,OAAT,CAAiBD,QAAjB,CAAjC,EAA6D;IACzD,IAAIJ,YAAY,KAAKT,KAArB,EAA4B;MACxB,OAAOH,gBAAgB,CAACkB,SAAjB,GAA6BlB,gBAAgB,CAACmB,YAArD;IACH;;IACD,OAAOnB,gBAAgB,CAACkB,SAAxB;EACH;;EACD,IAAIN,YAAY,KAAKV,KAArB,EAA4B;IACxB,OAAOF,gBAAgB,CAACoB,SAAjB,GAA6BpB,gBAAgB,CAACqB,QAArD;EACH;;EACD,OAAOrB,gBAAgB,CAACoB,SAAxB;AACH;;AA/CDrB;AAiDA;;;;;;;;;;AASA,SAAgBuB,UAAhB,CAA8ChC,KAA9C,EAAwD;EACpDA,KAAK,GAAGA,KAAK,CAACiC,MAAN,CAAa,UAAC9B,IAAD,EAAO+B,CAAP,EAAUC,GAAV,EAAa;IAAK,QAACA,GAAG,CAAC3B,QAAJ,CAAaL,IAAb,EAAmB+B,CAAC,GAAG,CAAvB,CAAD;EAA0B,CAAzD,CAAR;EAEAlC,KAAK,CAACoC,IAAN,CAAW,UAACC,CAAD,EAAIC,CAAJ,EAAK;IACZ,IAAMC,QAAQ,GAAG5B,uBAAuB,CAAC0B,CAAD,EAAIC,CAAJ,CAAxC;;IACA,IAAIC,QAAQ,GAAG7B,gBAAgB,CAACoB,SAAhC,EAA2C;MACvC,OAAO,CAAC,CAAR;IACH,CAFD,MAEO,IAAIS,QAAQ,GAAG7B,gBAAgB,CAACkB,SAAhC,EAA2C;MAC9C,OAAO,CAAP;IACH;;IACD,OAAO,CAAP;EACH,CARD;EAUA,OAAO5B,KAAP;AACH;;AAdDS","names":["removeSubsets","nodes","idx","length","node","lastIndexOf","splice","ancestor","parent","includes","exports","DocumentPosition","compareDocumentPosition","nodeA","nodeB","aParents","bParents","current","unshift","maxIdx","Math","min","DISCONNECTED","sharedParent","siblings","children","aSibling","bSibling","indexOf","FOLLOWING","CONTAINED_BY","PRECEDING","CONTAINS","uniqueSort","filter","i","arr","sort","a","b","relative"],"sources":["helpers.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sparseArray = void 0;\n\nconst tuple_1 = require(\"./tuple\");\n\nconst uniqueArray_1 = require(\"./uniqueArray\");\n\nconst RestrictedIntegerArbitraryBuilder_1 = require(\"./_internals/builders/RestrictedIntegerArbitraryBuilder\");\n\nconst MaxLengthFromMinLength_1 = require(\"./_internals/helpers/MaxLengthFromMinLength\");\n\nfunction extractMaxIndex(indexesAndValues) {\n  let maxIndex = -1;\n\n  for (let index = 0; index !== indexesAndValues.length; ++index) {\n    maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);\n  }\n\n  return maxIndex;\n}\n\nfunction arrayFromItems(length, indexesAndValues) {\n  const array = Array(length);\n\n  for (let index = 0; index !== indexesAndValues.length; ++index) {\n    const it = indexesAndValues[index];\n    if (it[0] < length) array[it[0]] = it[1];\n  }\n\n  return array;\n}\n\nfunction sparseArray(arb) {\n  let constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    size,\n    minNumElements = 0,\n    maxLength = MaxLengthFromMinLength_1.MaxLengthUpperBound,\n    maxNumElements = maxLength,\n    noTrailingHole,\n    depthIdentifier\n  } = constraints;\n  const maxGeneratedNumElements = (0, MaxLengthFromMinLength_1.maxGeneratedLengthFromSizeForArbitrary)(size, minNumElements, maxNumElements, constraints.maxNumElements !== undefined);\n  const maxGeneratedLength = (0, MaxLengthFromMinLength_1.maxGeneratedLengthFromSizeForArbitrary)(size, maxGeneratedNumElements, maxLength, constraints.maxLength !== undefined);\n\n  if (minNumElements > maxLength) {\n    throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);\n  }\n\n  if (minNumElements > maxNumElements) {\n    throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);\n  }\n\n  const resultedMaxNumElements = Math.min(maxNumElements, maxLength);\n  const resultedSizeMaxNumElements = constraints.maxNumElements !== undefined || size !== undefined ? size : '=';\n  const maxGeneratedIndexAuthorized = Math.max(maxGeneratedLength - 1, 0);\n  const maxIndexAuthorized = Math.max(maxLength - 1, 0);\n  const sparseArrayNoTrailingHole = (0, uniqueArray_1.uniqueArray)((0, tuple_1.tuple)((0, RestrictedIntegerArbitraryBuilder_1.restrictedIntegerArbitraryBuilder)(0, maxGeneratedIndexAuthorized, maxIndexAuthorized), arb), {\n    size: resultedSizeMaxNumElements,\n    minLength: minNumElements,\n    maxLength: resultedMaxNumElements,\n    selector: item => item[0],\n    depthIdentifier\n  }).map(items => {\n    const lastIndex = extractMaxIndex(items);\n    return arrayFromItems(lastIndex + 1, items);\n  }, value => {\n    if (!Array.isArray(value)) {\n      throw new Error('Not supported entry type');\n    }\n\n    if (noTrailingHole && value.length !== 0 && !(value.length - 1 in value)) {\n      throw new Error('No trailing hole');\n    }\n\n    return Object.entries(value).map(entry => [Number(entry[0]), entry[1]]);\n  });\n\n  if (noTrailingHole || maxLength === minNumElements) {\n    return sparseArrayNoTrailingHole;\n  }\n\n  return (0, tuple_1.tuple)(sparseArrayNoTrailingHole, (0, RestrictedIntegerArbitraryBuilder_1.restrictedIntegerArbitraryBuilder)(minNumElements, maxGeneratedLength, maxLength)).map(data => {\n    const sparse = data[0];\n    const targetLength = data[1];\n\n    if (sparse.length >= targetLength) {\n      return sparse;\n    }\n\n    const longerSparse = sparse.slice();\n    longerSparse.length = targetLength;\n    return longerSparse;\n  }, value => {\n    if (!Array.isArray(value)) {\n      throw new Error('Not supported entry type');\n    }\n\n    return [value, value.length];\n  });\n}\n\nexports.sparseArray = sparseArray;","map":{"version":3,"names":["Object","defineProperty","exports","value","sparseArray","tuple_1","require","uniqueArray_1","RestrictedIntegerArbitraryBuilder_1","MaxLengthFromMinLength_1","extractMaxIndex","indexesAndValues","maxIndex","index","length","Math","max","arrayFromItems","array","Array","it","arb","constraints","size","minNumElements","maxLength","MaxLengthUpperBound","maxNumElements","noTrailingHole","depthIdentifier","maxGeneratedNumElements","maxGeneratedLengthFromSizeForArbitrary","undefined","maxGeneratedLength","Error","resultedMaxNumElements","min","resultedSizeMaxNumElements","maxGeneratedIndexAuthorized","maxIndexAuthorized","sparseArrayNoTrailingHole","uniqueArray","tuple","restrictedIntegerArbitraryBuilder","minLength","selector","item","map","items","lastIndex","isArray","entries","entry","Number","data","sparse","targetLength","longerSparse","slice"],"sources":["/Users/tranminhtrung/Desktop/learn_web3/gamble/node_modules/fast-check/lib/arbitrary/sparseArray.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sparseArray = void 0;\nconst tuple_1 = require(\"./tuple\");\nconst uniqueArray_1 = require(\"./uniqueArray\");\nconst RestrictedIntegerArbitraryBuilder_1 = require(\"./_internals/builders/RestrictedIntegerArbitraryBuilder\");\nconst MaxLengthFromMinLength_1 = require(\"./_internals/helpers/MaxLengthFromMinLength\");\nfunction extractMaxIndex(indexesAndValues) {\n    let maxIndex = -1;\n    for (let index = 0; index !== indexesAndValues.length; ++index) {\n        maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);\n    }\n    return maxIndex;\n}\nfunction arrayFromItems(length, indexesAndValues) {\n    const array = Array(length);\n    for (let index = 0; index !== indexesAndValues.length; ++index) {\n        const it = indexesAndValues[index];\n        if (it[0] < length)\n            array[it[0]] = it[1];\n    }\n    return array;\n}\nfunction sparseArray(arb, constraints = {}) {\n    const { size, minNumElements = 0, maxLength = MaxLengthFromMinLength_1.MaxLengthUpperBound, maxNumElements = maxLength, noTrailingHole, depthIdentifier, } = constraints;\n    const maxGeneratedNumElements = (0, MaxLengthFromMinLength_1.maxGeneratedLengthFromSizeForArbitrary)(size, minNumElements, maxNumElements, constraints.maxNumElements !== undefined);\n    const maxGeneratedLength = (0, MaxLengthFromMinLength_1.maxGeneratedLengthFromSizeForArbitrary)(size, maxGeneratedNumElements, maxLength, constraints.maxLength !== undefined);\n    if (minNumElements > maxLength) {\n        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);\n    }\n    if (minNumElements > maxNumElements) {\n        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);\n    }\n    const resultedMaxNumElements = Math.min(maxNumElements, maxLength);\n    const resultedSizeMaxNumElements = constraints.maxNumElements !== undefined || size !== undefined ? size : '=';\n    const maxGeneratedIndexAuthorized = Math.max(maxGeneratedLength - 1, 0);\n    const maxIndexAuthorized = Math.max(maxLength - 1, 0);\n    const sparseArrayNoTrailingHole = (0, uniqueArray_1.uniqueArray)((0, tuple_1.tuple)((0, RestrictedIntegerArbitraryBuilder_1.restrictedIntegerArbitraryBuilder)(0, maxGeneratedIndexAuthorized, maxIndexAuthorized), arb), {\n        size: resultedSizeMaxNumElements,\n        minLength: minNumElements,\n        maxLength: resultedMaxNumElements,\n        selector: (item) => item[0],\n        depthIdentifier,\n    }).map((items) => {\n        const lastIndex = extractMaxIndex(items);\n        return arrayFromItems(lastIndex + 1, items);\n    }, (value) => {\n        if (!Array.isArray(value)) {\n            throw new Error('Not supported entry type');\n        }\n        if (noTrailingHole && value.length !== 0 && !(value.length - 1 in value)) {\n            throw new Error('No trailing hole');\n        }\n        return Object.entries(value).map((entry) => [Number(entry[0]), entry[1]]);\n    });\n    if (noTrailingHole || maxLength === minNumElements) {\n        return sparseArrayNoTrailingHole;\n    }\n    return (0, tuple_1.tuple)(sparseArrayNoTrailingHole, (0, RestrictedIntegerArbitraryBuilder_1.restrictedIntegerArbitraryBuilder)(minNumElements, maxGeneratedLength, maxLength)).map((data) => {\n        const sparse = data[0];\n        const targetLength = data[1];\n        if (sparse.length >= targetLength) {\n            return sparse;\n        }\n        const longerSparse = sparse.slice();\n        longerSparse.length = targetLength;\n        return longerSparse;\n    }, (value) => {\n        if (!Array.isArray(value)) {\n            throw new Error('Not supported entry type');\n        }\n        return [value, value.length];\n    });\n}\nexports.sparseArray = sparseArray;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SchedulerImplem = void 0;\n\nconst TextEscaper_1 = require(\"../helpers/TextEscaper\");\n\nconst symbols_1 = require(\"../../../check/symbols\");\n\nconst stringify_1 = require(\"../../../utils/stringify\");\n\nclass SchedulerImplem {\n  constructor(act, taskSelector) {\n    this.act = act;\n    this.taskSelector = taskSelector;\n    this.lastTaskId = 0;\n    this.sourceTaskSelector = taskSelector.clone();\n    this.scheduledTasks = [];\n    this.triggeredTasks = [];\n    this.scheduledWatchers = [];\n  }\n\n  static buildLog(reportItem) {\n    return `[task\\${${reportItem.taskId}}] ${reportItem.label.length !== 0 ? `${reportItem.schedulingType}::${reportItem.label}` : reportItem.schedulingType} ${reportItem.status}${reportItem.outputValue !== undefined ? ` with value ${(0, TextEscaper_1.escapeForTemplateString)(reportItem.outputValue)}` : ''}`;\n  }\n\n  log(schedulingType, taskId, label, metadata, status, data) {\n    this.triggeredTasks.push({\n      status,\n      schedulingType,\n      taskId,\n      label,\n      metadata,\n      outputValue: data !== undefined ? (0, stringify_1.stringify)(data) : undefined\n    });\n  }\n\n  scheduleInternal(schedulingType, label, task, metadata, thenTaskToBeAwaited) {\n    let trigger = null;\n    const taskId = ++this.lastTaskId;\n    const scheduledPromise = new Promise((resolve, reject) => {\n      trigger = () => {\n        (thenTaskToBeAwaited ? task.then(() => thenTaskToBeAwaited()) : task).then(data => {\n          this.log(schedulingType, taskId, label, metadata, 'resolved', data);\n          return resolve(data);\n        }, err => {\n          this.log(schedulingType, taskId, label, metadata, 'rejected', err);\n          return reject(err);\n        });\n      };\n    });\n    this.scheduledTasks.push({\n      original: task,\n      scheduled: scheduledPromise,\n      trigger: trigger,\n      schedulingType,\n      taskId,\n      label,\n      metadata\n    });\n\n    if (this.scheduledWatchers.length !== 0) {\n      this.scheduledWatchers[0]();\n    }\n\n    return scheduledPromise;\n  }\n\n  schedule(task, label, metadata) {\n    return this.scheduleInternal('promise', label || '', task, metadata);\n  }\n\n  scheduleFunction(asyncFunction) {\n    var _this = this;\n\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _this.scheduleInternal('function', `${asyncFunction.name}(${args.map(stringify_1.stringify).join(',')})`, asyncFunction(...args), undefined);\n    };\n  }\n\n  scheduleSequence(sequenceBuilders) {\n    const status = {\n      done: false,\n      faulty: false\n    };\n    const dummyResolvedPromise = {\n      then: f => f()\n    };\n\n    let resolveSequenceTask = () => {};\n\n    const sequenceTask = new Promise(resolve => resolveSequenceTask = resolve);\n    sequenceBuilders.reduce((previouslyScheduled, item) => {\n      const [builder, label, metadata] = typeof item === 'function' ? [item, item.name, undefined] : [item.builder, item.label, item.metadata];\n      return previouslyScheduled.then(() => {\n        const scheduled = this.scheduleInternal('sequence', label, dummyResolvedPromise, metadata, () => builder());\n        scheduled.catch(() => {\n          status.faulty = true;\n          resolveSequenceTask();\n        });\n        return scheduled;\n      });\n    }, dummyResolvedPromise).then(() => {\n      status.done = true;\n      resolveSequenceTask();\n    }, () => {});\n    return Object.assign(status, {\n      task: Promise.resolve(sequenceTask).then(() => {\n        return {\n          done: status.done,\n          faulty: status.faulty\n        };\n      })\n    });\n  }\n\n  count() {\n    return this.scheduledTasks.length;\n  }\n\n  async internalWaitOne() {\n    if (this.scheduledTasks.length === 0) {\n      throw new Error('No task scheduled');\n    }\n\n    const taskIndex = this.taskSelector.nextTaskIndex(this.scheduledTasks);\n    const [scheduledTask] = this.scheduledTasks.splice(taskIndex, 1);\n    scheduledTask.trigger();\n\n    try {\n      await scheduledTask.scheduled;\n    } catch (_err) {}\n  }\n\n  async waitOne() {\n    await this.act(async () => await this.internalWaitOne());\n  }\n\n  async waitAll() {\n    while (this.scheduledTasks.length > 0) {\n      await this.waitOne();\n    }\n  }\n\n  async waitFor(unscheduledTask) {\n    let taskResolved = false;\n    let awaiterPromise = null;\n\n    const awaiter = async () => {\n      while (!taskResolved && this.scheduledTasks.length > 0) {\n        await this.waitOne();\n      }\n\n      awaiterPromise = null;\n    };\n\n    const handleNotified = () => {\n      if (awaiterPromise !== null) {\n        return;\n      }\n\n      awaiterPromise = Promise.resolve().then(awaiter);\n    };\n\n    const clearAndReplaceWatcher = () => {\n      const handleNotifiedIndex = this.scheduledWatchers.indexOf(handleNotified);\n\n      if (handleNotifiedIndex !== -1) {\n        this.scheduledWatchers.splice(handleNotifiedIndex, 1);\n      }\n\n      if (handleNotifiedIndex === 0 && this.scheduledWatchers.length !== 0) {\n        this.scheduledWatchers[0]();\n      }\n    };\n\n    const rewrappedTask = unscheduledTask.then(ret => {\n      taskResolved = true;\n\n      if (awaiterPromise === null) {\n        clearAndReplaceWatcher();\n        return ret;\n      }\n\n      return awaiterPromise.then(() => {\n        clearAndReplaceWatcher();\n        return ret;\n      });\n    }, err => {\n      taskResolved = true;\n\n      if (awaiterPromise === null) {\n        clearAndReplaceWatcher();\n        throw err;\n      }\n\n      return awaiterPromise.then(() => {\n        clearAndReplaceWatcher();\n        throw err;\n      });\n    });\n\n    if (this.scheduledTasks.length > 0 && this.scheduledWatchers.length === 0) {\n      handleNotified();\n    }\n\n    this.scheduledWatchers.push(handleNotified);\n    return rewrappedTask;\n  }\n\n  report() {\n    return [...this.triggeredTasks, ...this.scheduledTasks.map(t => ({\n      status: 'pending',\n      schedulingType: t.schedulingType,\n      taskId: t.taskId,\n      label: t.label,\n      metadata: t.metadata\n    }))];\n  }\n\n  toString() {\n    return 'schedulerFor()`\\n' + this.report().map(SchedulerImplem.buildLog).map(log => `-> ${log}`).join('\\n') + '`';\n  }\n\n  [symbols_1.cloneMethod]() {\n    return new SchedulerImplem(this.act, this.sourceTaskSelector);\n  }\n\n}\n\nexports.SchedulerImplem = SchedulerImplem;","map":{"version":3,"names":["Object","defineProperty","exports","value","SchedulerImplem","TextEscaper_1","require","symbols_1","stringify_1","constructor","act","taskSelector","lastTaskId","sourceTaskSelector","clone","scheduledTasks","triggeredTasks","scheduledWatchers","buildLog","reportItem","taskId","label","length","schedulingType","status","outputValue","undefined","escapeForTemplateString","log","metadata","data","push","stringify","scheduleInternal","task","thenTaskToBeAwaited","trigger","scheduledPromise","Promise","resolve","reject","then","err","original","scheduled","schedule","scheduleFunction","asyncFunction","args","name","map","join","scheduleSequence","sequenceBuilders","done","faulty","dummyResolvedPromise","f","resolveSequenceTask","sequenceTask","reduce","previouslyScheduled","item","builder","catch","assign","count","internalWaitOne","Error","taskIndex","nextTaskIndex","scheduledTask","splice","_err","waitOne","waitAll","waitFor","unscheduledTask","taskResolved","awaiterPromise","awaiter","handleNotified","clearAndReplaceWatcher","handleNotifiedIndex","indexOf","rewrappedTask","ret","report","t","toString","cloneMethod"],"sources":["/Users/tranminhtrung/Desktop/learn_web3/gamble/node_modules/fast-check/lib/arbitrary/_internals/implementations/SchedulerImplem.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SchedulerImplem = void 0;\nconst TextEscaper_1 = require(\"../helpers/TextEscaper\");\nconst symbols_1 = require(\"../../../check/symbols\");\nconst stringify_1 = require(\"../../../utils/stringify\");\nclass SchedulerImplem {\n    constructor(act, taskSelector) {\n        this.act = act;\n        this.taskSelector = taskSelector;\n        this.lastTaskId = 0;\n        this.sourceTaskSelector = taskSelector.clone();\n        this.scheduledTasks = [];\n        this.triggeredTasks = [];\n        this.scheduledWatchers = [];\n    }\n    static buildLog(reportItem) {\n        return `[task\\${${reportItem.taskId}}] ${reportItem.label.length !== 0 ? `${reportItem.schedulingType}::${reportItem.label}` : reportItem.schedulingType} ${reportItem.status}${reportItem.outputValue !== undefined ? ` with value ${(0, TextEscaper_1.escapeForTemplateString)(reportItem.outputValue)}` : ''}`;\n    }\n    log(schedulingType, taskId, label, metadata, status, data) {\n        this.triggeredTasks.push({\n            status,\n            schedulingType,\n            taskId,\n            label,\n            metadata,\n            outputValue: data !== undefined ? (0, stringify_1.stringify)(data) : undefined,\n        });\n    }\n    scheduleInternal(schedulingType, label, task, metadata, thenTaskToBeAwaited) {\n        let trigger = null;\n        const taskId = ++this.lastTaskId;\n        const scheduledPromise = new Promise((resolve, reject) => {\n            trigger = () => {\n                (thenTaskToBeAwaited ? task.then(() => thenTaskToBeAwaited()) : task).then((data) => {\n                    this.log(schedulingType, taskId, label, metadata, 'resolved', data);\n                    return resolve(data);\n                }, (err) => {\n                    this.log(schedulingType, taskId, label, metadata, 'rejected', err);\n                    return reject(err);\n                });\n            };\n        });\n        this.scheduledTasks.push({\n            original: task,\n            scheduled: scheduledPromise,\n            trigger: trigger,\n            schedulingType,\n            taskId,\n            label,\n            metadata,\n        });\n        if (this.scheduledWatchers.length !== 0) {\n            this.scheduledWatchers[0]();\n        }\n        return scheduledPromise;\n    }\n    schedule(task, label, metadata) {\n        return this.scheduleInternal('promise', label || '', task, metadata);\n    }\n    scheduleFunction(asyncFunction) {\n        return (...args) => this.scheduleInternal('function', `${asyncFunction.name}(${args.map(stringify_1.stringify).join(',')})`, asyncFunction(...args), undefined);\n    }\n    scheduleSequence(sequenceBuilders) {\n        const status = { done: false, faulty: false };\n        const dummyResolvedPromise = { then: (f) => f() };\n        let resolveSequenceTask = () => { };\n        const sequenceTask = new Promise((resolve) => (resolveSequenceTask = resolve));\n        sequenceBuilders\n            .reduce((previouslyScheduled, item) => {\n            const [builder, label, metadata] = typeof item === 'function' ? [item, item.name, undefined] : [item.builder, item.label, item.metadata];\n            return previouslyScheduled.then(() => {\n                const scheduled = this.scheduleInternal('sequence', label, dummyResolvedPromise, metadata, () => builder());\n                scheduled.catch(() => {\n                    status.faulty = true;\n                    resolveSequenceTask();\n                });\n                return scheduled;\n            });\n        }, dummyResolvedPromise)\n            .then(() => {\n            status.done = true;\n            resolveSequenceTask();\n        }, () => {\n        });\n        return Object.assign(status, {\n            task: Promise.resolve(sequenceTask).then(() => {\n                return { done: status.done, faulty: status.faulty };\n            }),\n        });\n    }\n    count() {\n        return this.scheduledTasks.length;\n    }\n    async internalWaitOne() {\n        if (this.scheduledTasks.length === 0) {\n            throw new Error('No task scheduled');\n        }\n        const taskIndex = this.taskSelector.nextTaskIndex(this.scheduledTasks);\n        const [scheduledTask] = this.scheduledTasks.splice(taskIndex, 1);\n        scheduledTask.trigger();\n        try {\n            await scheduledTask.scheduled;\n        }\n        catch (_err) {\n        }\n    }\n    async waitOne() {\n        await this.act(async () => await this.internalWaitOne());\n    }\n    async waitAll() {\n        while (this.scheduledTasks.length > 0) {\n            await this.waitOne();\n        }\n    }\n    async waitFor(unscheduledTask) {\n        let taskResolved = false;\n        let awaiterPromise = null;\n        const awaiter = async () => {\n            while (!taskResolved && this.scheduledTasks.length > 0) {\n                await this.waitOne();\n            }\n            awaiterPromise = null;\n        };\n        const handleNotified = () => {\n            if (awaiterPromise !== null) {\n                return;\n            }\n            awaiterPromise = Promise.resolve().then(awaiter);\n        };\n        const clearAndReplaceWatcher = () => {\n            const handleNotifiedIndex = this.scheduledWatchers.indexOf(handleNotified);\n            if (handleNotifiedIndex !== -1) {\n                this.scheduledWatchers.splice(handleNotifiedIndex, 1);\n            }\n            if (handleNotifiedIndex === 0 && this.scheduledWatchers.length !== 0) {\n                this.scheduledWatchers[0]();\n            }\n        };\n        const rewrappedTask = unscheduledTask.then((ret) => {\n            taskResolved = true;\n            if (awaiterPromise === null) {\n                clearAndReplaceWatcher();\n                return ret;\n            }\n            return awaiterPromise.then(() => {\n                clearAndReplaceWatcher();\n                return ret;\n            });\n        }, (err) => {\n            taskResolved = true;\n            if (awaiterPromise === null) {\n                clearAndReplaceWatcher();\n                throw err;\n            }\n            return awaiterPromise.then(() => {\n                clearAndReplaceWatcher();\n                throw err;\n            });\n        });\n        if (this.scheduledTasks.length > 0 && this.scheduledWatchers.length === 0) {\n            handleNotified();\n        }\n        this.scheduledWatchers.push(handleNotified);\n        return rewrappedTask;\n    }\n    report() {\n        return [\n            ...this.triggeredTasks,\n            ...this.scheduledTasks.map((t) => ({\n                status: 'pending',\n                schedulingType: t.schedulingType,\n                taskId: t.taskId,\n                label: t.label,\n                metadata: t.metadata,\n            })),\n        ];\n    }\n    toString() {\n        return ('schedulerFor()`\\n' +\n            this.report()\n                .map(SchedulerImplem.buildLog)\n                .map((log) => `-> ${log}`)\n                .join('\\n') +\n            '`');\n    }\n    [symbols_1.cloneMethod]() {\n        return new SchedulerImplem(this.act, this.sourceTaskSelector);\n    }\n}\nexports.SchedulerImplem = SchedulerImplem;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
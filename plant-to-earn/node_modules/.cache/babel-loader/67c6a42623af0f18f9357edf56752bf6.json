{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FrequencyArbitrary = void 0;\n\nconst Stream_1 = require(\"../../stream/Stream\");\n\nconst Arbitrary_1 = require(\"../../check/arbitrary/definition/Arbitrary\");\n\nconst Value_1 = require(\"../../check/arbitrary/definition/Value\");\n\nconst DepthContext_1 = require(\"./helpers/DepthContext\");\n\nconst MaxLengthFromMinLength_1 = require(\"./helpers/MaxLengthFromMinLength\");\n\nclass FrequencyArbitrary extends Arbitrary_1.Arbitrary {\n  constructor(warbs, constraints, context) {\n    super();\n    this.warbs = warbs;\n    this.constraints = constraints;\n    this.context = context;\n    let currentWeight = 0;\n    this.cumulatedWeights = [];\n\n    for (let idx = 0; idx !== warbs.length; ++idx) {\n      currentWeight += warbs[idx].weight;\n      this.cumulatedWeights.push(currentWeight);\n    }\n\n    this.totalWeight = currentWeight;\n  }\n\n  static from(warbs, constraints, label) {\n    if (warbs.length === 0) {\n      throw new Error(`${label} expects at least one weighted arbitrary`);\n    }\n\n    let totalWeight = 0;\n\n    for (let idx = 0; idx !== warbs.length; ++idx) {\n      const currentArbitrary = warbs[idx].arbitrary;\n\n      if (currentArbitrary === undefined) {\n        throw new Error(`${label} expects arbitraries to be specified`);\n      }\n\n      const currentWeight = warbs[idx].weight;\n      totalWeight += currentWeight;\n\n      if (!Number.isInteger(currentWeight)) {\n        throw new Error(`${label} expects weights to be integer values`);\n      }\n\n      if (currentWeight < 0) {\n        throw new Error(`${label} expects weights to be superior or equal to 0`);\n      }\n    }\n\n    if (totalWeight <= 0) {\n      throw new Error(`${label} expects the sum of weights to be strictly superior to 0`);\n    }\n\n    const sanitizedConstraints = {\n      depthBias: (0, MaxLengthFromMinLength_1.depthBiasFromSizeForArbitrary)(constraints.depthSize, constraints.maxDepth !== undefined),\n      maxDepth: constraints.maxDepth != undefined ? constraints.maxDepth : Number.POSITIVE_INFINITY,\n      withCrossShrink: !!constraints.withCrossShrink\n    };\n    return new FrequencyArbitrary(warbs, sanitizedConstraints, (0, DepthContext_1.getDepthContextFor)(constraints.depthIdentifier));\n  }\n\n  generate(mrng, biasFactor) {\n    if (this.mustGenerateFirst()) {\n      return this.safeGenerateForIndex(mrng, 0, biasFactor);\n    }\n\n    const selected = mrng.nextInt(this.computeNegDepthBenefit(), this.totalWeight - 1);\n\n    for (let idx = 0; idx !== this.cumulatedWeights.length; ++idx) {\n      if (selected < this.cumulatedWeights[idx]) {\n        return this.safeGenerateForIndex(mrng, idx, biasFactor);\n      }\n    }\n\n    throw new Error(`Unable to generate from fc.frequency`);\n  }\n\n  canShrinkWithoutContext(value) {\n    return this.canShrinkWithoutContextIndex(value) !== -1;\n  }\n\n  shrink(value, context) {\n    if (context !== undefined) {\n      const safeContext = context;\n      const selectedIndex = safeContext.selectedIndex;\n      const originalBias = safeContext.originalBias;\n      const originalArbitrary = this.warbs[selectedIndex].arbitrary;\n      const originalShrinks = originalArbitrary.shrink(value, safeContext.originalContext).map(v => this.mapIntoValue(selectedIndex, v, null, originalBias));\n\n      if (safeContext.clonedMrngForFallbackFirst !== null) {\n        if (safeContext.cachedGeneratedForFirst === undefined) {\n          safeContext.cachedGeneratedForFirst = this.safeGenerateForIndex(safeContext.clonedMrngForFallbackFirst, 0, originalBias);\n        }\n\n        const valueFromFirst = safeContext.cachedGeneratedForFirst;\n        return Stream_1.Stream.of(valueFromFirst).join(originalShrinks);\n      }\n\n      return originalShrinks;\n    }\n\n    const potentialSelectedIndex = this.canShrinkWithoutContextIndex(value);\n\n    if (potentialSelectedIndex === -1) {\n      return Stream_1.Stream.nil();\n    }\n\n    return this.defaultShrinkForFirst(potentialSelectedIndex).join(this.warbs[potentialSelectedIndex].arbitrary.shrink(value, undefined).map(v => this.mapIntoValue(potentialSelectedIndex, v, null, undefined)));\n  }\n\n  defaultShrinkForFirst(selectedIndex) {\n    ++this.context.depth;\n\n    try {\n      if (!this.mustFallbackToFirstInShrink(selectedIndex) || this.warbs[0].fallbackValue === undefined) {\n        return Stream_1.Stream.nil();\n      }\n    } finally {\n      --this.context.depth;\n    }\n\n    const rawShrinkValue = new Value_1.Value(this.warbs[0].fallbackValue.default, undefined);\n    return Stream_1.Stream.of(this.mapIntoValue(0, rawShrinkValue, null, undefined));\n  }\n\n  canShrinkWithoutContextIndex(value) {\n    if (this.mustGenerateFirst()) {\n      return this.warbs[0].arbitrary.canShrinkWithoutContext(value) ? 0 : -1;\n    }\n\n    try {\n      ++this.context.depth;\n\n      for (let idx = 0; idx !== this.warbs.length; ++idx) {\n        const warb = this.warbs[idx];\n\n        if (warb.weight !== 0 && warb.arbitrary.canShrinkWithoutContext(value)) {\n          return idx;\n        }\n      }\n\n      return -1;\n    } finally {\n      --this.context.depth;\n    }\n  }\n\n  mapIntoValue(idx, value, clonedMrngForFallbackFirst, biasFactor) {\n    const context = {\n      selectedIndex: idx,\n      originalBias: biasFactor,\n      originalContext: value.context,\n      clonedMrngForFallbackFirst\n    };\n    return new Value_1.Value(value.value, context);\n  }\n\n  safeGenerateForIndex(mrng, idx, biasFactor) {\n    ++this.context.depth;\n\n    try {\n      const value = this.warbs[idx].arbitrary.generate(mrng, biasFactor);\n      const clonedMrngForFallbackFirst = this.mustFallbackToFirstInShrink(idx) ? mrng.clone() : null;\n      return this.mapIntoValue(idx, value, clonedMrngForFallbackFirst, biasFactor);\n    } finally {\n      --this.context.depth;\n    }\n  }\n\n  mustGenerateFirst() {\n    return this.constraints.maxDepth <= this.context.depth;\n  }\n\n  mustFallbackToFirstInShrink(idx) {\n    return idx !== 0 && this.constraints.withCrossShrink && this.warbs[0].weight !== 0;\n  }\n\n  computeNegDepthBenefit() {\n    const depthBias = this.constraints.depthBias;\n\n    if (depthBias <= 0 || this.warbs[0].weight === 0) {\n      return 0;\n    }\n\n    const depthBenefit = Math.floor(Math.pow(1 + depthBias, this.context.depth)) - 1;\n    return -Math.min(this.totalWeight * depthBenefit, Number.MAX_SAFE_INTEGER) || 0;\n  }\n\n}\n\nexports.FrequencyArbitrary = FrequencyArbitrary;","map":{"version":3,"names":["Object","defineProperty","exports","value","FrequencyArbitrary","Stream_1","require","Arbitrary_1","Value_1","DepthContext_1","MaxLengthFromMinLength_1","Arbitrary","constructor","warbs","constraints","context","currentWeight","cumulatedWeights","idx","length","weight","push","totalWeight","from","label","Error","currentArbitrary","arbitrary","undefined","Number","isInteger","sanitizedConstraints","depthBias","depthBiasFromSizeForArbitrary","depthSize","maxDepth","POSITIVE_INFINITY","withCrossShrink","getDepthContextFor","depthIdentifier","generate","mrng","biasFactor","mustGenerateFirst","safeGenerateForIndex","selected","nextInt","computeNegDepthBenefit","canShrinkWithoutContext","canShrinkWithoutContextIndex","shrink","safeContext","selectedIndex","originalBias","originalArbitrary","originalShrinks","originalContext","map","v","mapIntoValue","clonedMrngForFallbackFirst","cachedGeneratedForFirst","valueFromFirst","Stream","of","join","potentialSelectedIndex","nil","defaultShrinkForFirst","depth","mustFallbackToFirstInShrink","fallbackValue","rawShrinkValue","Value","default","warb","clone","depthBenefit","Math","floor","pow","min","MAX_SAFE_INTEGER"],"sources":["/Users/tranminhtrung/Desktop/learn_web3/gamble/node_modules/fast-check/lib/arbitrary/_internals/FrequencyArbitrary.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FrequencyArbitrary = void 0;\nconst Stream_1 = require(\"../../stream/Stream\");\nconst Arbitrary_1 = require(\"../../check/arbitrary/definition/Arbitrary\");\nconst Value_1 = require(\"../../check/arbitrary/definition/Value\");\nconst DepthContext_1 = require(\"./helpers/DepthContext\");\nconst MaxLengthFromMinLength_1 = require(\"./helpers/MaxLengthFromMinLength\");\nclass FrequencyArbitrary extends Arbitrary_1.Arbitrary {\n    constructor(warbs, constraints, context) {\n        super();\n        this.warbs = warbs;\n        this.constraints = constraints;\n        this.context = context;\n        let currentWeight = 0;\n        this.cumulatedWeights = [];\n        for (let idx = 0; idx !== warbs.length; ++idx) {\n            currentWeight += warbs[idx].weight;\n            this.cumulatedWeights.push(currentWeight);\n        }\n        this.totalWeight = currentWeight;\n    }\n    static from(warbs, constraints, label) {\n        if (warbs.length === 0) {\n            throw new Error(`${label} expects at least one weighted arbitrary`);\n        }\n        let totalWeight = 0;\n        for (let idx = 0; idx !== warbs.length; ++idx) {\n            const currentArbitrary = warbs[idx].arbitrary;\n            if (currentArbitrary === undefined) {\n                throw new Error(`${label} expects arbitraries to be specified`);\n            }\n            const currentWeight = warbs[idx].weight;\n            totalWeight += currentWeight;\n            if (!Number.isInteger(currentWeight)) {\n                throw new Error(`${label} expects weights to be integer values`);\n            }\n            if (currentWeight < 0) {\n                throw new Error(`${label} expects weights to be superior or equal to 0`);\n            }\n        }\n        if (totalWeight <= 0) {\n            throw new Error(`${label} expects the sum of weights to be strictly superior to 0`);\n        }\n        const sanitizedConstraints = {\n            depthBias: (0, MaxLengthFromMinLength_1.depthBiasFromSizeForArbitrary)(constraints.depthSize, constraints.maxDepth !== undefined),\n            maxDepth: constraints.maxDepth != undefined ? constraints.maxDepth : Number.POSITIVE_INFINITY,\n            withCrossShrink: !!constraints.withCrossShrink,\n        };\n        return new FrequencyArbitrary(warbs, sanitizedConstraints, (0, DepthContext_1.getDepthContextFor)(constraints.depthIdentifier));\n    }\n    generate(mrng, biasFactor) {\n        if (this.mustGenerateFirst()) {\n            return this.safeGenerateForIndex(mrng, 0, biasFactor);\n        }\n        const selected = mrng.nextInt(this.computeNegDepthBenefit(), this.totalWeight - 1);\n        for (let idx = 0; idx !== this.cumulatedWeights.length; ++idx) {\n            if (selected < this.cumulatedWeights[idx]) {\n                return this.safeGenerateForIndex(mrng, idx, biasFactor);\n            }\n        }\n        throw new Error(`Unable to generate from fc.frequency`);\n    }\n    canShrinkWithoutContext(value) {\n        return this.canShrinkWithoutContextIndex(value) !== -1;\n    }\n    shrink(value, context) {\n        if (context !== undefined) {\n            const safeContext = context;\n            const selectedIndex = safeContext.selectedIndex;\n            const originalBias = safeContext.originalBias;\n            const originalArbitrary = this.warbs[selectedIndex].arbitrary;\n            const originalShrinks = originalArbitrary\n                .shrink(value, safeContext.originalContext)\n                .map((v) => this.mapIntoValue(selectedIndex, v, null, originalBias));\n            if (safeContext.clonedMrngForFallbackFirst !== null) {\n                if (safeContext.cachedGeneratedForFirst === undefined) {\n                    safeContext.cachedGeneratedForFirst = this.safeGenerateForIndex(safeContext.clonedMrngForFallbackFirst, 0, originalBias);\n                }\n                const valueFromFirst = safeContext.cachedGeneratedForFirst;\n                return Stream_1.Stream.of(valueFromFirst).join(originalShrinks);\n            }\n            return originalShrinks;\n        }\n        const potentialSelectedIndex = this.canShrinkWithoutContextIndex(value);\n        if (potentialSelectedIndex === -1) {\n            return Stream_1.Stream.nil();\n        }\n        return this.defaultShrinkForFirst(potentialSelectedIndex).join(this.warbs[potentialSelectedIndex].arbitrary\n            .shrink(value, undefined)\n            .map((v) => this.mapIntoValue(potentialSelectedIndex, v, null, undefined)));\n    }\n    defaultShrinkForFirst(selectedIndex) {\n        ++this.context.depth;\n        try {\n            if (!this.mustFallbackToFirstInShrink(selectedIndex) || this.warbs[0].fallbackValue === undefined) {\n                return Stream_1.Stream.nil();\n            }\n        }\n        finally {\n            --this.context.depth;\n        }\n        const rawShrinkValue = new Value_1.Value(this.warbs[0].fallbackValue.default, undefined);\n        return Stream_1.Stream.of(this.mapIntoValue(0, rawShrinkValue, null, undefined));\n    }\n    canShrinkWithoutContextIndex(value) {\n        if (this.mustGenerateFirst()) {\n            return this.warbs[0].arbitrary.canShrinkWithoutContext(value) ? 0 : -1;\n        }\n        try {\n            ++this.context.depth;\n            for (let idx = 0; idx !== this.warbs.length; ++idx) {\n                const warb = this.warbs[idx];\n                if (warb.weight !== 0 && warb.arbitrary.canShrinkWithoutContext(value)) {\n                    return idx;\n                }\n            }\n            return -1;\n        }\n        finally {\n            --this.context.depth;\n        }\n    }\n    mapIntoValue(idx, value, clonedMrngForFallbackFirst, biasFactor) {\n        const context = {\n            selectedIndex: idx,\n            originalBias: biasFactor,\n            originalContext: value.context,\n            clonedMrngForFallbackFirst,\n        };\n        return new Value_1.Value(value.value, context);\n    }\n    safeGenerateForIndex(mrng, idx, biasFactor) {\n        ++this.context.depth;\n        try {\n            const value = this.warbs[idx].arbitrary.generate(mrng, biasFactor);\n            const clonedMrngForFallbackFirst = this.mustFallbackToFirstInShrink(idx) ? mrng.clone() : null;\n            return this.mapIntoValue(idx, value, clonedMrngForFallbackFirst, biasFactor);\n        }\n        finally {\n            --this.context.depth;\n        }\n    }\n    mustGenerateFirst() {\n        return this.constraints.maxDepth <= this.context.depth;\n    }\n    mustFallbackToFirstInShrink(idx) {\n        return idx !== 0 && this.constraints.withCrossShrink && this.warbs[0].weight !== 0;\n    }\n    computeNegDepthBenefit() {\n        const depthBias = this.constraints.depthBias;\n        if (depthBias <= 0 || this.warbs[0].weight === 0) {\n            return 0;\n        }\n        const depthBenefit = Math.floor(Math.pow(1 + depthBias, this.context.depth)) - 1;\n        return -Math.min(this.totalWeight * depthBenefit, Number.MAX_SAFE_INTEGER) || 0;\n    }\n}\nexports.FrequencyArbitrary = FrequencyArbitrary;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TupleArbitrary = void 0;\n\nconst Stream_1 = require(\"../../stream/Stream\");\n\nconst symbols_1 = require(\"../../check/symbols\");\n\nconst Arbitrary_1 = require(\"../../check/arbitrary/definition/Arbitrary\");\n\nconst Value_1 = require(\"../../check/arbitrary/definition/Value\");\n\nclass TupleArbitrary extends Arbitrary_1.Arbitrary {\n  constructor(arbs) {\n    super();\n    this.arbs = arbs;\n\n    for (let idx = 0; idx !== arbs.length; ++idx) {\n      const arb = arbs[idx];\n      if (arb == null || arb.generate == null) throw new Error(`Invalid parameter encountered at index ${idx}: expecting an Arbitrary`);\n    }\n  }\n\n  static makeItCloneable(vs, values) {\n    return Object.defineProperty(vs, symbols_1.cloneMethod, {\n      value: () => {\n        const cloned = [];\n\n        for (let idx = 0; idx !== values.length; ++idx) {\n          cloned.push(values[idx].value);\n        }\n\n        TupleArbitrary.makeItCloneable(cloned, values);\n        return cloned;\n      }\n    });\n  }\n\n  static wrapper(values) {\n    let cloneable = false;\n    const vs = [];\n    const ctxs = [];\n\n    for (let idx = 0; idx !== values.length; ++idx) {\n      const v = values[idx];\n      cloneable = cloneable || v.hasToBeCloned;\n      vs.push(v.value);\n      ctxs.push(v.context);\n    }\n\n    if (cloneable) {\n      TupleArbitrary.makeItCloneable(vs, values);\n    }\n\n    return new Value_1.Value(vs, ctxs);\n  }\n\n  generate(mrng, biasFactor) {\n    return TupleArbitrary.wrapper(this.arbs.map(a => a.generate(mrng, biasFactor)));\n  }\n\n  canShrinkWithoutContext(value) {\n    if (!Array.isArray(value) || value.length !== this.arbs.length) {\n      return false;\n    }\n\n    for (let index = 0; index !== this.arbs.length; ++index) {\n      if (!this.arbs[index].canShrinkWithoutContext(value[index])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  shrink(value, context) {\n    let s = Stream_1.Stream.nil();\n    const safeContext = Array.isArray(context) ? context : [];\n\n    for (let idx = 0; idx !== this.arbs.length; ++idx) {\n      const shrinksForIndex = this.arbs[idx].shrink(value[idx], safeContext[idx]).map(v => {\n        const nextValues = value.map((v, idx) => new Value_1.Value((0, symbols_1.cloneIfNeeded)(v), safeContext[idx]));\n        return nextValues.slice(0, idx).concat([v]).concat(nextValues.slice(idx + 1));\n      }).map(values => TupleArbitrary.wrapper(values));\n      s = s.join(shrinksForIndex);\n    }\n\n    return s;\n  }\n\n}\n\nexports.TupleArbitrary = TupleArbitrary;","map":{"version":3,"names":["Object","defineProperty","exports","value","TupleArbitrary","Stream_1","require","symbols_1","Arbitrary_1","Value_1","Arbitrary","constructor","arbs","idx","length","arb","generate","Error","makeItCloneable","vs","values","cloneMethod","cloned","push","wrapper","cloneable","ctxs","v","hasToBeCloned","context","Value","mrng","biasFactor","map","a","canShrinkWithoutContext","Array","isArray","index","shrink","s","Stream","nil","safeContext","shrinksForIndex","nextValues","cloneIfNeeded","slice","concat","join"],"sources":["/Users/tranminhtrung/Desktop/learn_web3/gamble/node_modules/fast-check/lib/arbitrary/_internals/TupleArbitrary.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TupleArbitrary = void 0;\nconst Stream_1 = require(\"../../stream/Stream\");\nconst symbols_1 = require(\"../../check/symbols\");\nconst Arbitrary_1 = require(\"../../check/arbitrary/definition/Arbitrary\");\nconst Value_1 = require(\"../../check/arbitrary/definition/Value\");\nclass TupleArbitrary extends Arbitrary_1.Arbitrary {\n    constructor(arbs) {\n        super();\n        this.arbs = arbs;\n        for (let idx = 0; idx !== arbs.length; ++idx) {\n            const arb = arbs[idx];\n            if (arb == null || arb.generate == null)\n                throw new Error(`Invalid parameter encountered at index ${idx}: expecting an Arbitrary`);\n        }\n    }\n    static makeItCloneable(vs, values) {\n        return Object.defineProperty(vs, symbols_1.cloneMethod, {\n            value: () => {\n                const cloned = [];\n                for (let idx = 0; idx !== values.length; ++idx) {\n                    cloned.push(values[idx].value);\n                }\n                TupleArbitrary.makeItCloneable(cloned, values);\n                return cloned;\n            },\n        });\n    }\n    static wrapper(values) {\n        let cloneable = false;\n        const vs = [];\n        const ctxs = [];\n        for (let idx = 0; idx !== values.length; ++idx) {\n            const v = values[idx];\n            cloneable = cloneable || v.hasToBeCloned;\n            vs.push(v.value);\n            ctxs.push(v.context);\n        }\n        if (cloneable) {\n            TupleArbitrary.makeItCloneable(vs, values);\n        }\n        return new Value_1.Value(vs, ctxs);\n    }\n    generate(mrng, biasFactor) {\n        return TupleArbitrary.wrapper(this.arbs.map((a) => a.generate(mrng, biasFactor)));\n    }\n    canShrinkWithoutContext(value) {\n        if (!Array.isArray(value) || value.length !== this.arbs.length) {\n            return false;\n        }\n        for (let index = 0; index !== this.arbs.length; ++index) {\n            if (!this.arbs[index].canShrinkWithoutContext(value[index])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    shrink(value, context) {\n        let s = Stream_1.Stream.nil();\n        const safeContext = Array.isArray(context) ? context : [];\n        for (let idx = 0; idx !== this.arbs.length; ++idx) {\n            const shrinksForIndex = this.arbs[idx]\n                .shrink(value[idx], safeContext[idx])\n                .map((v) => {\n                const nextValues = value.map((v, idx) => new Value_1.Value((0, symbols_1.cloneIfNeeded)(v), safeContext[idx]));\n                return nextValues\n                    .slice(0, idx)\n                    .concat([v])\n                    .concat(nextValues.slice(idx + 1));\n            })\n                .map((values) => TupleArbitrary.wrapper(values));\n            s = s.join(shrinksForIndex);\n        }\n        return s;\n    }\n}\nexports.TupleArbitrary = TupleArbitrary;\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,cAAR,GAAyB,KAAK,CAA9B;;AACA,MAAMC,QAAQ,GAAGC,OAAO,CAAC,qBAAD,CAAxB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,qBAAD,CAAzB;;AACA,MAAME,WAAW,GAAGF,OAAO,CAAC,4CAAD,CAA3B;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,wCAAD,CAAvB;;AACA,MAAMF,cAAN,SAA6BI,WAAW,CAACE,SAAzC,CAAmD;EAC/CC,WAAW,CAACC,IAAD,EAAO;IACd;IACA,KAAKA,IAAL,GAAYA,IAAZ;;IACA,KAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,KAAKD,IAAI,CAACE,MAA/B,EAAuC,EAAED,GAAzC,EAA8C;MAC1C,MAAME,GAAG,GAAGH,IAAI,CAACC,GAAD,CAAhB;MACA,IAAIE,GAAG,IAAI,IAAP,IAAeA,GAAG,CAACC,QAAJ,IAAgB,IAAnC,EACI,MAAM,IAAIC,KAAJ,CAAW,0CAAyCJ,GAAI,0BAAxD,CAAN;IACP;EACJ;;EACqB,OAAfK,eAAe,CAACC,EAAD,EAAKC,MAAL,EAAa;IAC/B,OAAOpB,MAAM,CAACC,cAAP,CAAsBkB,EAAtB,EAA0BZ,SAAS,CAACc,WAApC,EAAiD;MACpDlB,KAAK,EAAE,MAAM;QACT,MAAMmB,MAAM,GAAG,EAAf;;QACA,KAAK,IAAIT,GAAG,GAAG,CAAf,EAAkBA,GAAG,KAAKO,MAAM,CAACN,MAAjC,EAAyC,EAAED,GAA3C,EAAgD;UAC5CS,MAAM,CAACC,IAAP,CAAYH,MAAM,CAACP,GAAD,CAAN,CAAYV,KAAxB;QACH;;QACDC,cAAc,CAACc,eAAf,CAA+BI,MAA/B,EAAuCF,MAAvC;QACA,OAAOE,MAAP;MACH;IARmD,CAAjD,CAAP;EAUH;;EACa,OAAPE,OAAO,CAACJ,MAAD,EAAS;IACnB,IAAIK,SAAS,GAAG,KAAhB;IACA,MAAMN,EAAE,GAAG,EAAX;IACA,MAAMO,IAAI,GAAG,EAAb;;IACA,KAAK,IAAIb,GAAG,GAAG,CAAf,EAAkBA,GAAG,KAAKO,MAAM,CAACN,MAAjC,EAAyC,EAAED,GAA3C,EAAgD;MAC5C,MAAMc,CAAC,GAAGP,MAAM,CAACP,GAAD,CAAhB;MACAY,SAAS,GAAGA,SAAS,IAAIE,CAAC,CAACC,aAA3B;MACAT,EAAE,CAACI,IAAH,CAAQI,CAAC,CAACxB,KAAV;MACAuB,IAAI,CAACH,IAAL,CAAUI,CAAC,CAACE,OAAZ;IACH;;IACD,IAAIJ,SAAJ,EAAe;MACXrB,cAAc,CAACc,eAAf,CAA+BC,EAA/B,EAAmCC,MAAnC;IACH;;IACD,OAAO,IAAIX,OAAO,CAACqB,KAAZ,CAAkBX,EAAlB,EAAsBO,IAAtB,CAAP;EACH;;EACDV,QAAQ,CAACe,IAAD,EAAOC,UAAP,EAAmB;IACvB,OAAO5B,cAAc,CAACoB,OAAf,CAAuB,KAAKZ,IAAL,CAAUqB,GAAV,CAAeC,CAAD,IAAOA,CAAC,CAAClB,QAAF,CAAWe,IAAX,EAAiBC,UAAjB,CAArB,CAAvB,CAAP;EACH;;EACDG,uBAAuB,CAAChC,KAAD,EAAQ;IAC3B,IAAI,CAACiC,KAAK,CAACC,OAAN,CAAclC,KAAd,CAAD,IAAyBA,KAAK,CAACW,MAAN,KAAiB,KAAKF,IAAL,CAAUE,MAAxD,EAAgE;MAC5D,OAAO,KAAP;IACH;;IACD,KAAK,IAAIwB,KAAK,GAAG,CAAjB,EAAoBA,KAAK,KAAK,KAAK1B,IAAL,CAAUE,MAAxC,EAAgD,EAAEwB,KAAlD,EAAyD;MACrD,IAAI,CAAC,KAAK1B,IAAL,CAAU0B,KAAV,EAAiBH,uBAAjB,CAAyChC,KAAK,CAACmC,KAAD,CAA9C,CAAL,EAA6D;QACzD,OAAO,KAAP;MACH;IACJ;;IACD,OAAO,IAAP;EACH;;EACDC,MAAM,CAACpC,KAAD,EAAQ0B,OAAR,EAAiB;IACnB,IAAIW,CAAC,GAAGnC,QAAQ,CAACoC,MAAT,CAAgBC,GAAhB,EAAR;IACA,MAAMC,WAAW,GAAGP,KAAK,CAACC,OAAN,CAAcR,OAAd,IAAyBA,OAAzB,GAAmC,EAAvD;;IACA,KAAK,IAAIhB,GAAG,GAAG,CAAf,EAAkBA,GAAG,KAAK,KAAKD,IAAL,CAAUE,MAApC,EAA4C,EAAED,GAA9C,EAAmD;MAC/C,MAAM+B,eAAe,GAAG,KAAKhC,IAAL,CAAUC,GAAV,EACnB0B,MADmB,CACZpC,KAAK,CAACU,GAAD,CADO,EACA8B,WAAW,CAAC9B,GAAD,CADX,EAEnBoB,GAFmB,CAEdN,CAAD,IAAO;QACZ,MAAMkB,UAAU,GAAG1C,KAAK,CAAC8B,GAAN,CAAU,CAACN,CAAD,EAAId,GAAJ,KAAY,IAAIJ,OAAO,CAACqB,KAAZ,CAAkB,CAAC,GAAGvB,SAAS,CAACuC,aAAd,EAA6BnB,CAA7B,CAAlB,EAAmDgB,WAAW,CAAC9B,GAAD,CAA9D,CAAtB,CAAnB;QACA,OAAOgC,UAAU,CACZE,KADE,CACI,CADJ,EACOlC,GADP,EAEFmC,MAFE,CAEK,CAACrB,CAAD,CAFL,EAGFqB,MAHE,CAGKH,UAAU,CAACE,KAAX,CAAiBlC,GAAG,GAAG,CAAvB,CAHL,CAAP;MAIH,CARuB,EASnBoB,GATmB,CASdb,MAAD,IAAYhB,cAAc,CAACoB,OAAf,CAAuBJ,MAAvB,CATG,CAAxB;MAUAoB,CAAC,GAAGA,CAAC,CAACS,IAAF,CAAOL,eAAP,CAAJ;IACH;;IACD,OAAOJ,CAAP;EACH;;AApE8C;;AAsEnDtC,OAAO,CAACE,cAAR,GAAyBA,cAAzB"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.double = void 0;\n\nconst ArrayInt64_1 = require(\"./_internals/helpers/ArrayInt64\");\n\nconst ArrayInt64Arbitrary_1 = require(\"./_internals/ArrayInt64Arbitrary\");\n\nconst DoubleHelpers_1 = require(\"./_internals/helpers/DoubleHelpers\");\n\nfunction safeDoubleToIndex(d, constraintsLabel) {\n  if (Number.isNaN(d)) {\n    throw new Error('fc.double constraints.' + constraintsLabel + ' must be a 32-bit float');\n  }\n\n  return (0, DoubleHelpers_1.doubleToIndex)(d);\n}\n\nfunction unmapperDoubleToIndex(value) {\n  if (typeof value !== 'number') throw new Error('Unsupported type');\n  return (0, DoubleHelpers_1.doubleToIndex)(value);\n}\n\nfunction double() {\n  let constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    noDefaultInfinity = false,\n    noNaN = false,\n    min = noDefaultInfinity ? -Number.MAX_VALUE : Number.NEGATIVE_INFINITY,\n    max = noDefaultInfinity ? Number.MAX_VALUE : Number.POSITIVE_INFINITY\n  } = constraints;\n  const minIndex = safeDoubleToIndex(min, 'min');\n  const maxIndex = safeDoubleToIndex(max, 'max');\n\n  if ((0, ArrayInt64_1.isStrictlySmaller64)(maxIndex, minIndex)) {\n    throw new Error('fc.double constraints.min must be smaller or equal to constraints.max');\n  }\n\n  if (noNaN) {\n    return (0, ArrayInt64Arbitrary_1.arrayInt64)(minIndex, maxIndex).map(DoubleHelpers_1.indexToDouble, unmapperDoubleToIndex);\n  }\n\n  const positiveMaxIdx = (0, ArrayInt64_1.isStrictlyPositive64)(maxIndex);\n  const minIndexWithNaN = positiveMaxIdx ? minIndex : (0, ArrayInt64_1.substract64)(minIndex, ArrayInt64_1.Unit64);\n  const maxIndexWithNaN = positiveMaxIdx ? (0, ArrayInt64_1.add64)(maxIndex, ArrayInt64_1.Unit64) : maxIndex;\n  return (0, ArrayInt64Arbitrary_1.arrayInt64)(minIndexWithNaN, maxIndexWithNaN).map(index => {\n    if ((0, ArrayInt64_1.isStrictlySmaller64)(maxIndex, index) || (0, ArrayInt64_1.isStrictlySmaller64)(index, minIndex)) return Number.NaN;else return (0, DoubleHelpers_1.indexToDouble)(index);\n  }, value => {\n    if (typeof value !== 'number') throw new Error('Unsupported type');\n    if (Number.isNaN(value)) return !(0, ArrayInt64_1.isEqual64)(maxIndex, maxIndexWithNaN) ? maxIndexWithNaN : minIndexWithNaN;\n    return (0, DoubleHelpers_1.doubleToIndex)(value);\n  });\n}\n\nexports.double = double;","map":{"version":3,"names":["Object","defineProperty","exports","value","double","ArrayInt64_1","require","ArrayInt64Arbitrary_1","DoubleHelpers_1","safeDoubleToIndex","d","constraintsLabel","Number","isNaN","Error","doubleToIndex","unmapperDoubleToIndex","constraints","noDefaultInfinity","noNaN","min","MAX_VALUE","NEGATIVE_INFINITY","max","POSITIVE_INFINITY","minIndex","maxIndex","isStrictlySmaller64","arrayInt64","map","indexToDouble","positiveMaxIdx","isStrictlyPositive64","minIndexWithNaN","substract64","Unit64","maxIndexWithNaN","add64","index","NaN","isEqual64"],"sources":["/Users/tranminhtrung/Desktop/learn_web3/gamble/node_modules/fast-check/lib/arbitrary/double.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.double = void 0;\nconst ArrayInt64_1 = require(\"./_internals/helpers/ArrayInt64\");\nconst ArrayInt64Arbitrary_1 = require(\"./_internals/ArrayInt64Arbitrary\");\nconst DoubleHelpers_1 = require(\"./_internals/helpers/DoubleHelpers\");\nfunction safeDoubleToIndex(d, constraintsLabel) {\n    if (Number.isNaN(d)) {\n        throw new Error('fc.double constraints.' + constraintsLabel + ' must be a 32-bit float');\n    }\n    return (0, DoubleHelpers_1.doubleToIndex)(d);\n}\nfunction unmapperDoubleToIndex(value) {\n    if (typeof value !== 'number')\n        throw new Error('Unsupported type');\n    return (0, DoubleHelpers_1.doubleToIndex)(value);\n}\nfunction double(constraints = {}) {\n    const { noDefaultInfinity = false, noNaN = false, min = noDefaultInfinity ? -Number.MAX_VALUE : Number.NEGATIVE_INFINITY, max = noDefaultInfinity ? Number.MAX_VALUE : Number.POSITIVE_INFINITY, } = constraints;\n    const minIndex = safeDoubleToIndex(min, 'min');\n    const maxIndex = safeDoubleToIndex(max, 'max');\n    if ((0, ArrayInt64_1.isStrictlySmaller64)(maxIndex, minIndex)) {\n        throw new Error('fc.double constraints.min must be smaller or equal to constraints.max');\n    }\n    if (noNaN) {\n        return (0, ArrayInt64Arbitrary_1.arrayInt64)(minIndex, maxIndex).map(DoubleHelpers_1.indexToDouble, unmapperDoubleToIndex);\n    }\n    const positiveMaxIdx = (0, ArrayInt64_1.isStrictlyPositive64)(maxIndex);\n    const minIndexWithNaN = positiveMaxIdx ? minIndex : (0, ArrayInt64_1.substract64)(minIndex, ArrayInt64_1.Unit64);\n    const maxIndexWithNaN = positiveMaxIdx ? (0, ArrayInt64_1.add64)(maxIndex, ArrayInt64_1.Unit64) : maxIndex;\n    return (0, ArrayInt64Arbitrary_1.arrayInt64)(minIndexWithNaN, maxIndexWithNaN).map((index) => {\n        if ((0, ArrayInt64_1.isStrictlySmaller64)(maxIndex, index) || (0, ArrayInt64_1.isStrictlySmaller64)(index, minIndex))\n            return Number.NaN;\n        else\n            return (0, DoubleHelpers_1.indexToDouble)(index);\n    }, (value) => {\n        if (typeof value !== 'number')\n            throw new Error('Unsupported type');\n        if (Number.isNaN(value))\n            return !(0, ArrayInt64_1.isEqual64)(maxIndex, maxIndexWithNaN) ? maxIndexWithNaN : minIndexWithNaN;\n        return (0, DoubleHelpers_1.doubleToIndex)(value);\n    });\n}\nexports.double = double;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}